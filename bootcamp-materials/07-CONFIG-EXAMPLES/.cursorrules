# Cursor Rules - Systematic AI-Assisted Development

## Core Development Philosophy

Follow systematic, documented workflows using structured prompts and artifacts. Every project deserves clear requirements, execution plans, and decision documentation.

---

## The 5-Mode Framework

When generating code or solving problems, structure work using these 5 modes in sequence:

### Mode 1: Constitution
**Purpose:** Define project-wide rules and constraints

**Contains:**
- Standards that apply everywhere in the codebase
- Non-negotiable patterns and conventions
- Quality gates and requirements
- Technology constraints

**Format:**
```markdown
# Constitution

## Rules
- [Rule category]: [Specific pattern]

## Constraints
- [What must/must not happen]

## Quality Standards
✅ Code must: [requirement]
❌ Code must NOT: [anti-pattern]
```

**When to write:** Once per project, reuse across all files

---

### Mode 2: Specification
**Purpose:** Define what to build in this specific component

**Contains:**
- Current state description
- Target state description
- Success criteria (measurable)
- Actual code or requirements

**Format:**
```markdown
# Specification

## Current State
[What exists now]

## Target State
[What it should become]

## Success Criteria
✓ [Testable condition 1]
✓ [Testable condition 2]

## Context
[Relevant code, data, or documentation]
```

**When to write:** Once per component/file/feature

---

### Mode 3: Planning
**Purpose:** Define step-by-step execution approach

**Contains:**
- Phases with dependencies
- Tasks with validation points
- Time estimates
- Risk assessment

**Format:**
```markdown
# Planning

## Phase 1: [Name] (Est: X time)
Why first: [Dependency reasoning]
- Task 1.1: [Specific action]
- Task 1.2: [Specific action]
- Validation: [How to verify completion]

## Phase 2: [Name] (Est: X time)
Why second: [Dependency reasoning]
- Task 2.1: [Specific action]
- Validation: [How to verify completion]
```

**When to write:** Once per approach, reusable for similar work

---

### Mode 4: ABCD Clarification
**Purpose:** Document decision points with clear options

**Contains:**
- Context requiring decision
- 4 options (A, B, C, D) with tradeoffs
- Recommendation with reasoning
- Final choice documentation

**Format:**
```markdown
# ABCD Clarification

---
Decision Point: [What needs deciding]

Recommended: Option [X] - [Why]

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| A | [Approach] | [Benefits] | [Drawbacks] |
| B | [Approach] | [Benefits] | [Drawbacks] |
| C | [Approach] | [Benefits] | [Drawbacks] |
| D | [Approach] | [Benefits] | [Drawbacks] |

Decision: [What was chosen]
Rationale: [Why this choice]
---
```

**When to write:** Only when multiple valid approaches exist

---

### Mode 5: Implementation
**Purpose:** Synthesize all context and generate solution

**Contains:**
- References to all previous modes
- Complete input data/code
- Clear generation instructions
- Expected output format

**Format:**
```markdown
# Implementation

## Context Loaded
From Constitution: [Key rules]
From Specification: [Target description]
From Planning: [Execution approach]
From ABCD: [Decisions made]

## Input
[Code, data, or requirements to transform]

## Instructions
Generate [output] that:
- Follows all Constitution rules
- Meets Specification criteria
- Implements Planning approach
- Uses ABCD decisions
```

**When to write:** Every time you need generation/solution

---

## Spec-Driven Artifacts

Maintain these living documents for every feature or project:

### mainspec.md
**Human-written requirements and acceptance criteria**

```markdown
# Feature Specification: [Name]

## Overview
[What and why in 2-3 sentences]

## Requirements

### Functional Requirements
- [ ] [What it must do]
- [ ] [What it must do]

### Non-Functional Requirements
- Performance: [Metrics]
- Security: [Requirements]
- Scalability: [Requirements]

## Acceptance Criteria
- [ ] [How you know it's done]
- [ ] [How you know it's done]

## Technical Approach
[High-level implementation strategy]

## Dependencies & Constraints
- Requires: [Prerequisites]
- Cannot: [Limitations]

## Out of Scope
[Explicitly what this does NOT include]
```

---

### implementation_plan.md
**AI-generated execution roadmap with tasks and risks**

```markdown
# Implementation Plan: [Name]

## Discovery Summary
[What was researched and learned]

## Implementation Phases

### Phase 1: [Name] (Est: X time)
- [ ] Task 1
  - Files/Components: [What's affected]
  - Dependencies: [What must be done first]
  - Risk Level: [Low/Medium/High]
  - Validation: [How to verify]

### Phase 2: [Name] (Est: X time)
- [ ] Task 2
  - Files/Components: [What's affected]
  - Dependencies: [Prerequisites]
  - Risk Level: [Low/Medium/High]
  - Validation: [How to verify]

## Risk Assessment
- **Risk:** [Description]
  - Probability: [Low/Medium/High]
  - Impact: [Low/Medium/High]
  - Mitigation: [Strategy]

## Definition of Done
- [ ] All phases completed
- [ ] All tests passing
- [ ] Documentation updated
- [ ] Code reviewed
```

---

### knowledge_bank.md
**Living log of sessions, decisions, and learnings**

```markdown
# Knowledge Bank: [Name]

## Current Status
- Phase: [Current phase]
- Progress: [Percentage or milestone]
- Last Updated: [Date]

## Session Log

### Session [Date] [Time]
- Duration: [How long]
- Phase: [What phase of work]
- Completed: [What was done]
- Blockers: [Issues encountered]
- Next Steps: [What's next]

## Key Decisions

### [Decision Title]
- **Context:** [Why this decision was needed]
- **Options Considered:** [What alternatives]
- **Decision:** [What was chosen]
- **Rationale:** [Why this choice]
- **Trade-offs:** [What was sacrificed]
- **Validation:** [How to verify correctness]

## Learnings & Insights
- [What worked well]
- [What didn't work]
- [What to do differently next time]

## References
- [Links to research, docs, related work]
```

---

### research.md
**Discovery findings and integration analysis**

```markdown
# Research: [Name]

## Investigation Summary
[What was explored and why]

## Findings

### Technical Findings
- [What was discovered]
- [Constraints identified]
- [Opportunities found]

### Integration Points
- [How this connects to existing systems]
- [APIs or interfaces to use]
- [Dependencies to manage]

### Recommendations
- [Suggested approaches based on research]
- [Things to avoid]
- [Best practices to follow]
```

---

### notes.md
**Quick capture during active development**

```markdown
# Development Notes: [Name]

## [Date] - [Session]
- [Quick thought]
- [Decision made]
- [Question to answer]
- [Thing to remember]

## Ideas
- [Potential improvement]
- [Alternative approach]
- [Future consideration]

## Questions
- [Q]: [Question]
- [A]: [Answer or "TBD"]
```

---

## Code Generation Rules

### Universal Standards

**Always:**
- Follow the Constitution rules for this project
- Meet the Specification criteria
- Implement the Planning approach
- Use the ABCD decisions
- Write tests
- Document non-obvious logic
- Handle errors gracefully
- Consider edge cases

**Never:**
- Change behavior without understanding
- Skip validation steps
- Ignore security considerations
- Remove error handling
- Break existing contracts
- Introduce untracked dependencies

---

### Code Quality Standards

**Readability:**
- Clear variable and function names
- Consistent formatting
- Logical code organization
- Comments for "why" not "what"

**Maintainability:**
- Single responsibility principle
- Small, focused functions
- Minimal coupling
- Clear interfaces

**Reliability:**
- Input validation
- Error handling
- Edge case coverage
- Test coverage

---

## CLI Tool Patterns

When building command-line tools, follow these patterns:

**Structure:**
```python
#!/usr/bin/env python3
import argparse
import sys
import json

def main():
    parser = argparse.ArgumentParser(description='Clear purpose')
    parser.add_argument('--input', help='What it expects')
    parser.add_argument('--output', default='-', help='Where results go')
    parser.add_argument('--format', default='json', help='Output format')
    args = parser.parse_args()
    
    try:
        result = process(args.input)
        print(json.dumps(result))  # Structured output
        sys.exit(0)
    except Exception as e:
        print(json.dumps({"error": str(e)}), file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
```

**Principles:**
- Do one thing well
- Accept input via arguments or stdin
- Output structured data (JSON, CSV, etc.)
- Use proper exit codes
- Include --help documentation
- Enable composition via piping

---

## Response Guidelines

### When Asked About Architecture
- Propose systematic approach first
- Reference Constitution if exists
- Suggest creating one if doesn't exist
- Break into manageable phases
- Identify decision points

### When Writing Code
- Check Constitution rules first
- Understand Specification target
- Follow Planning approach
- Document key decisions
- Include validation steps

### When Solving Problems
- Understand current state fully
- Define clear target state
- Propose step-by-step plan
- Identify risks and tradeoffs
- Implement with full context

---

## Documentation Standards

### For Code
- Document WHY, not WHAT
- Explain non-obvious decisions
- Note important constraints
- Reference related components
- Keep comments up to date

### For Architecture
- Diagrams for complex flows
- Decision records for major choices
- API contracts for interfaces
- Runbooks for operations

### For Features
- User-facing documentation
- Developer setup guides
- Troubleshooting guides
- Change logs

---

## Quality Gates

### Before Committing Code
- [ ] Follows Constitution rules
- [ ] Meets Specification criteria
- [ ] Implements Planning approach
- [ ] Uses ABCD decisions
- [ ] Tests pass
- [ ] Documentation updated
- [ ] Code reviewed (if applicable)

### Before Closing Feature
- [ ] All acceptance criteria met
- [ ] All phases complete
- [ ] All tests passing
- [ ] Documentation complete
- [ ] Knowledge bank updated
- [ ] Lessons learned captured

---

## Workflow Patterns

### Pattern 1: New Feature
```
1. Create mainspec.md (requirements)
2. Research and document findings
3. Generate implementation_plan.md
4. Work through phases, documenting in knowledge_bank.md
5. Update notes.md throughout
6. Validate against acceptance criteria
```

### Pattern 2: Bug Fix
```
1. Document current behavior (research.md)
2. Define expected behavior (mainspec.md)
3. Plan fix approach (implementation_plan.md)
4. Implement and test
5. Document decision in knowledge_bank.md
```

### Pattern 3: Refactoring
```
1. Document current state and problems
2. Define target architecture
3. Plan incremental changes
4. Execute phase by phase
5. Validate behavior unchanged
6. Document architectural decisions
```

---

## Integration Patterns

### When Extending Existing Systems
- Document integration points in research.md
- Map dependencies and constraints
- Identify breaking change risks
- Plan backward compatibility
- Test integration thoroughly

### When Building APIs
- Define contracts upfront
- Version from day one
- Document all endpoints
- Provide usage examples
- Include error scenarios

### When Working with Data
- Validate inputs strictly
- Handle edge cases
- Document schemas
- Consider scale implications
- Test with realistic data

---

## Best Practices

### Start Every Project With
1. Constitution (project rules)
2. Mainspec (requirements)
3. Research (discovery)
4. Implementation plan (roadmap)

### During Development
- Update knowledge_bank.md regularly
- Capture decisions immediately
- Document blockers and solutions
- Keep notes.md for quick thoughts

### Before Completion
- Verify all acceptance criteria
- Update all documentation
- Capture lessons learned
- Plan for maintenance

---

## Error Prevention

### Common Mistakes to Avoid
- ❌ Starting without clear requirements
- ❌ Skipping planning phase
- ❌ Not documenting decisions
- ❌ Ignoring edge cases
- ❌ Missing validation steps

### Always Do
- ✅ Write mainspec before coding
- ✅ Plan approach systematically
- ✅ Document decisions with rationale
- ✅ Test thoroughly
- ✅ Update artifacts continuously

---

## Remember

This framework is **tool-agnostic** and **domain-agnostic**. 

It works for:
- Backend services
- Frontend applications
- Data pipelines
- Infrastructure automation
- API integrations
- Refactoring projects
- Bug fixes
- New features

**Core principle:** Systematic thinking + Clear documentation = Quality outcomes

Apply these patterns to ANY coding task for better results.
